# Java 并发编程实战

Java 并发编程实战 | 极客时间专栏学习笔记

## 开篇词

理论和实践总是有鸿沟的。

并发编程很重要，非常重要，找工作面试时深有体会（2019-7-16）。

管程模型。信号量模型。

并发编程核心问题：分工，同步，互斥。


坚持，遇到问题不是逃避或者抱怨。

## 学习攻略

### 跳出来，看全景。

#### 分工

Java SDK 并发包里的 Executor、Fork/Join、Future

#### 同步

线程间协作 CountDownLatch、CycliBarrier、Phaser、Exchanger

管程是解决并发问题的万能钥匙。

#### 互斥

所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。 🔒

内存模型：可见性问题，有序性问题，原子性问题

可见性： CPU 缓存
原子性： 操作系统

![并发编程-思维导图](https://static001.geekbang.org/resource/image/11/65/11e0c64618c04edba52619f41aaa3565.png)

### 钻进去，看本质

工程上的解决方案，一定要有理论做基础。技术的本质是背后的理论模型。


## 01. 可见性、原子性、有序性问题：并发编程Bug的源头

CPU 内存 I/O设备，速度差异

可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到

#### 缓存导致的可见性问题：

测试demo 还是有一些不能理解的地方

## 02. Java 内存模型

按需禁用缓存和编译优化

Java 内存模型是个很复杂的规范，规范了JVM如何按需禁用缓存和编译优化的方法。包括 volatile、synchronized、final 三个关键字，以及六项 Happens-Before 规则。

前面一个操作的结果对后续操作是可见的。

1. 程序的顺序性规则：程序前面对某个变量的修改一定是对后续操作可见的。
2. volatile 变量规则，对一个volatile变量的写操作，Happens-Before 于 后续对这个 volatile 变量的读操作。
3. 传递性
4. 管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。
5. 线程 start 规则，主线程A 启动 子线程B 后，子线程B 能够看到主线程在启动子线程B前的操作。
6. 线程 join 规则，主线程A 等待 子线程B 完成，当子线程B 完成后，主线程能够看到 子线程B 的操作。

final 修饰的变量，生而不变。

:::tip
Handongyang
老师，还差两个规则，分别是：
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。

所以，个人对于Java内存模型总结起来就是：
1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。
2. 三个基本原则：原子性、可见性、有序性。
3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。
4. Happens-Before的7个规则：
(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。
(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
5. Happens-Before的1个特性：传递性。
6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。
:::

## 03. 互斥锁 解决原子性问题

 原子性： 一个或者多个操作在 CPU 执行的过程中不被中断的特性。源头是线程切换，操作系统做线程切换是依赖CPU中断的。

 同一时刻只有一个线程执行，互斥。

 临界区：需要互斥执行的代码。

 sychronized 锁的一种实现，互斥锁。

 修饰代码块：锁定一个对象
 修饰静态方法： 锁定的是当前类的 Class 对象
 修饰非静态方法： 锁定的是当前实例对象 this

可见性，查询的方法也要加锁，happens-before 原则-加锁解锁

同一个资源，两把锁，会导致并发问题，互斥和可见性问题。

评论区：
:::tip

```java
class SafeCalc {
  long value = 0L;
  long get() {
    synchronized (new Object()) {
      return value;
    }
  }
  void addOne() {
    synchronized (new Object()) {
      value += 1;
    }
  }
}
```
1. 加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。
2. sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁，更改state加1拿锁，执行完代码，释放锁state减1，和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。
wait的时候，线程进waitset休眠，等待notify唤醒
3. 经过JVM逃逸分析的优化后，这个sync代码直接会被优化掉，所以在运行时该代码块是无锁的

:::

## 04. 互斥锁： 如何用一把锁保护多个资源

用不同的锁对受保护资源进行精细化管理，能够提升性能。 - 细粒度锁。

小结：

保护多个资源，关键点在于 分析多个资源之间的关系。如果资源之间没有关系，每个资源一把锁即可。如果多个资源存在关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。

原子性的本质是什么？多个资源间有一致性的要求，操作的中间状态对外不可见。解决原子性问题，保证中间状态对外不可见。

理解还是不够深刻！

## 05. 一不小心就死锁了，怎么办？

死锁：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。

1. 互斥
2. 占有且等待 一次性申请所有资源
3. 不可抢占 主动释放占有资源
4. 循环等待 按序申请资源，资源有顺序

识别出风险很重要。

## 06. 用“等待-通知” 机制优化循环等待

不满足 - 等待，阻塞自己
满足 - 通知，重新执行

一个完整的 等待-通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；
当要求的条件满足时，通知等待的线程，重新获取互斥锁。

用 synchronized 实现 等待-通知 机制

synchronized 配合 wait notify notifyAll

wait 方法会释放锁

尽量使用 notifyAll

## 07. 安全性、活跃性以及性能问题

线程安全：本质上是正确性，程序按照我们期望的执行，不要让我们感到意外。

存在共享数据，并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据。

活跃性问题：

活锁：路人谦让问题。

饥饿：保证资源充足，公平的分配资源，避免持有锁的线程长时间执行。

性能问题：

阿姆达尔定律

无锁的算法和数据结构：
线程本地存储 Thread Local Storage，TLS
写入时复制 Copy-on-write
乐观锁
原子类
Disruptor 无锁的内存队列

减少锁持有的时间，细粒度锁，ConcurrentHashMap，读写锁

## 08. 管程 并发编程的万能钥匙

管程和信号量是等价的。 Monitor

管理共享变量以及对共享变量的操作过程，让他们支持并发。管理类的成员变量和成员方法，让这个类是线程安全的。

MESA 模型：

Java 内置的 synchronized 管程方案。

:::danger
这一节不是很好理解啊! 需要多次螺旋。
:::

## 09. Java 线程的生命周期

Java 语言中线程共有六种状态：
1. NEW 初始化状态
2. RUNNABLE 可运行/运行状态
3. BOLOCKED 阻塞状态
4. WAITING 无时限等待
5. TIMED_WAITING 有时限等待
6. TERMINATED 终止状态

### 状态转换

#### 1. RUNNALE 与 BLOCKED 的状态转换：

线程等待 `synchronized` 的隐式锁，`sychronized` 修饰的方法，代码块在同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNALE 状态转换到 BLOCKED 状态。而当等待的线程获得 `synchronized` 隐式锁时，就又会从 BLOCKED 状态转换到 RUNNABLE 状态。

JVM层面并不关系操作系统调度相关的状态。Java在调用阻塞式API时，线程会阻塞，指的是操作系统线程的状态，并不是Java线程的状态，Java线程依然会保持 RUNNABLE 状态。

#### 2. RUNNABLE 与 WAITING 的状态转换：

总体来说，有三种场景会出发这种转换：

1. 获得 `sychronized` 隐式锁的线程，调用 无参数的 `Object.wait()` 方法。
2. 调用 无参数的 `Thread.join()` 方法。 当前线程会从 RUNNABLE 状态转换到 WAITING 状态，当 join 的线程执行完成之后，当前线程再转换为 RUNNABLE 状态。
3. 调用 `LockSupport.part()` 方法。

#### 3. RUNNABLE 与 TIMED_WAITING 的状态转换：

1. 调用 带超时参数的 Thread.sleep(long millis) 方法；
2. 获得 sychronized 隐式锁的线程，调用 带超时参数的 Object.wait(long timeout) 方法；
3. 调用带超时参数的 Thread.join(long millis) 方法；
4. 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；
5. 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法；

#### 4. 从 NEW 到 RUNNABLE 状态

创建Thread对象的两种方法：

1. 继承 Thread 对象
2. 实现Runnable 接口，重写 run() 方法，并将该类作为创建Thread对象的参数

调用线程对象的 `start()` 方法，状态转换为 RUNNABLE

#### 5. 从RUNNABLE 到 TERMINATED 状态

1. 线程执行完 run() 方法，会自动转换到 TERMINATED
2. 执行 run() 方法时异常抛出
3. stop(), interrupt()

### 总结

通过 `jstack` 命令 或者 Java VisualVM 可视化工具将 JVM所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态，调用栈，还包括了锁的信息。

## 10. 创建多少线程才是合适的？

为什么要使用多线程？

多线程的应用场景有哪些？

指标：延迟和吞吐量；提升I/O利用率，CPU 利用率。

I/O 密集型计算

CPU 密集型计算，提升多核CPU 的利用率， CPU核数 + 1

## 11. 为什么局部变量是线程安全的？

编译原理。

方法调用，计算机组成原理，CPU 调用栈。

局部变量存在哪里？调用栈。

每个线程都有自己独立的调用栈。

线程封闭。没有并发问题，性能很好。比如数据库连接池 Connections。

## 12. 如何用面向对象思想写好并发程序？

封装共享变量。

将属性和实现细节封装在对象内部。
对于不会发生变化的共享变量，建议final关键字修饰。


识别共享变量间的约束条件。

制定并发访问策略。

1. 避免共享
2. 不变模式
3. 管程以及其它同步工具

## 13. 理论基础模块小结


14篇 并发工工具类

## 14. Lock 和 Condition ： 隐藏在并发包中的管程

synchronized 无法实现 破坏不可抢占条件

1. 能够响应中断
2. 支持设置超时时间
3. 非阻塞地获取锁

可重入锁：是否可以多次获取锁

公平锁与非公平锁：默认非公平锁

1. 永远只在更新对象的成员变量时加锁
2. 永远只在访问可变的成员变量时加锁
3. 永远不在调用其它对象的方法时加锁
4. 减少持有锁的时间
5. 减小锁的粒度



## 15. Lock 和 Condition ：Dubbo 如何用管程实现异步转同步

## 16. Semaphore：如何快速实现一个限流器？

## 17. ReadWriteLock：如何快速实现一个完备的缓存？

## 18. StampedLock：有没有比读写锁更快的锁？

## 19. CountDownLatch 和 CyclicBarrier：如何让多线程步调一致？

## 20. 并发容器：都有哪些坑需要我们填？

## 21. 原子类：无锁工具类的典范

## 22. Executor 与线程池：如何创建正确的线程池？

## 23. Future：如何用多线程实现最优的烧水泡茶程序？

## 24. CompletableFuture：异步编程没那么难

## 25. CompletionService：如何批量执行异步任务？

## 26. Fork/Join 单机版的 MapReduce

## 27. 并发工具类模块总结



## 结束语

